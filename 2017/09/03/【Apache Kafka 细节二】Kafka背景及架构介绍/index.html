<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>【Apache Kafka 细节二】Kafka背景及架构介绍 | 我的学习记录</title><meta name="description" content="【Apache Kafka 细节二】Kafka背景及架构介绍"><meta name="keywords" content="Kafka"><meta name="author" content="陈 武"><meta name="copyright" content="陈 武"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://updatecg.oss-cn-beijing.aliyuncs.com/msofficexp.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://www.updatecg.xin/2017/09/03/【Apache Kafka 细节二】Kafka背景及架构介绍/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="【Apache Kafka 细节二】Kafka背景及架构介绍"><meta name="twitter:description" content="【Apache Kafka 细节二】Kafka背景及架构介绍"><meta name="twitter:image" content="https://updatecg.oss-cn-beijing.aliyuncs.com/timg.jpg"><meta property="og:type" content="article"><meta property="og:title" content="【Apache Kafka 细节二】Kafka背景及架构介绍"><meta property="og:url" content="http://www.updatecg.xin/2017/09/03/【Apache Kafka 细节二】Kafka背景及架构介绍/"><meta property="og:site_name" content="我的学习记录"><meta property="og:description" content="【Apache Kafka 细节二】Kafka背景及架构介绍"><meta property="og:image" content="https://updatecg.oss-cn-beijing.aliyuncs.com/timg.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="JavaSE 8" href="http://www.updatecg.xin/2017/09/09/JavaSE8/"><link rel="next" title="路上" href="http://www.updatecg.xin/2017/08/25/路上/"><meta name="baidu-site-verification" content="2zNdXBNuWf"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://www.updatecg.xin/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#摘要"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#背景介绍"><span class="toc-number">2.</span> <span class="toc-text">背景介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka创建背景"><span class="toc-number">2.1.</span> <span class="toc-text">Kafka创建背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka简介"><span class="toc-number">2.2.</span> <span class="toc-text">Kafka简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为何使用消息系统"><span class="toc-number">2.3.</span> <span class="toc-text">为何使用消息系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常用Message-Queue对比"><span class="toc-number">3.</span> <span class="toc-text">常用Message Queue对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka解析"><span class="toc-number">4.</span> <span class="toc-text">Kafka解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Terminology"><span class="toc-number">4.1.</span> <span class="toc-text">Terminology</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka架构"><span class="toc-number">5.</span> <span class="toc-text">Kafka架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Push-vs-Pull"><span class="toc-number">5.1.</span> <span class="toc-text">Push vs Pull</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Topic-amp-Partition"><span class="toc-number">5.2.</span> <span class="toc-text">Topic &amp; Partition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Replication-amp-Leader-election"><span class="toc-number">5.3.</span> <span class="toc-text">Replication &amp; Leader election</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Consumer-group"><span class="toc-number">5.4.</span> <span class="toc-text">Consumer group</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Consumer-Rebalance"><span class="toc-number">5.5.</span> <span class="toc-text">Consumer Rebalance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息Deliver-guarantee"><span class="toc-number">5.6.</span> <span class="toc-text">消息Deliver guarantee</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://updatecg.oss-cn-beijing.aliyuncs.com/wallhaven-2k3k39.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">我的学习记录</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="https://updatecg.oss-cn-beijing.aliyuncs.com/timg.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">决定一个人有多优秀的，并不是看他有多努力，而是看这个人的思维模式。</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/2016/10/01/chenwu/"><i class="fa-fw fa fa-smile-o"></i><span> 关于</span></a><a class="site-page" href="/messageBoard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a><a class="site-page" href="/2017/08/25/路上/"><i class="fa-fw fa fa-globe"></i><span> 旅行</span></a><a class="site-page" href="https://www.toolfk.com/"><i class="fa-fw fa fa-ambulance"></i><span> 工具库</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">【Apache Kafka 细节二】Kafka背景及架构介绍</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2017-09-03<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-28</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/闲时/">闲时</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">8,449</span><span class="post-meta__separator">|</span><span>阅读时长: 28 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote>
<p>摘要 ：KafKa是有LinkedIn开发并开源的分布式消息系统，因其分布式及高吐率而被广泛试用，现已与Cloudera Hadoop，Apache Storm，Apache Spark集成。本文介绍了Kafka的创建背景，设计目标，使用消息系统的优势以及目前流行的消息同对比。并介绍了Kafka的架构。Producer消息路由。Consumer Group以及由其实现的不同消息分布方式，Topic &amp; Partition，最后介绍了Kafka Consumer 为何试用pull模式以及Kafka提供的三种delivery guarantee.</p>
</blockquote>
<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h2 id="Kafka创建背景"><a href="#Kafka创建背景" class="headerlink" title="Kafka创建背景"></a>Kafka创建背景</h2><p>&#160; &#160; &#160; &#160;Kafka是一个消息系统，原本开发于LinkedIn，用作与LinkedIn的活动流（Activity Stream）和运营数据处理管道（Pipeline）的基础。现在它已被多家不同类型的公司作为多种类型的数据管道和消息系统试用。</p>
<p>&#160; &#160; &#160; &#160;活动流数据是几乎所有站点在对其网站试用情况做报表时都要用到的数据中最常规的部分。活动数据包括页面访问量（Page View）、被查看容方面的信息以及搜索情况等内容。这种数据通常的处理方式是先吧各种活动以日志的形式写入某种文件，然后周期性地对这些文件进行统计分析。运营数据指的是服务器的性能数据（CPU、IO使用率、请求时间、服务日志等等数据）。运营数据的统计方法种类繁多。</p>
<p>&#160; &#160; &#160; &#160;近年来，活动和运营数据处理已经成为了网站如愿产品特性中一个至关重要的组成部分，这就需要一套稍微更加复杂的基础设施对其提供支持。</p>
<h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p>&#160; &#160; &#160; &#160;Kafka是一种分布式的，基于发布/订阅的消息系统。主要设计目标如下：</p>
<ul>
<li>以时间复杂度为O（n）【n很大的时候，复杂度基本就不增长了，基本就是个常量C】的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100k条以上消息的传输</li>
<li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个Pratition内的消息顺序传输</li>
<li>同时支持离线数据处理和实时数据处理</li>
<li>Scale out :支持在线水平扩展</li>
</ul>
<h2 id="为何使用消息系统"><a href="#为何使用消息系统" class="headerlink" title="为何使用消息系统"></a>为何使用消息系统</h2><ul>
<li><p>解耦</p>
<p>&#160; &#160; &#160; &#160;在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守童谣的接口约束。</p>
</li>
<li><p>冗余</p>
<p>&#160; &#160; &#160; &#160;有些情况下，处理数据过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到他们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的“插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的该消息已经被处理完毕，从而取保你的数据被安全的保存直到你使用完毕。</p>
</li>
<li><p>扩展性</p>
<p>&#160; &#160; &#160; &#160;因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的。只要另外增加处理过程即可。不需要改变代码、不需要调节参数。</p>
</li>
<li><p>灵活性&amp;峰值处理能力</p>
<p>&#160; &#160; &#160; &#160;在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
</li>
<li><p>可恢复性</p>
<p>&#160; &#160; &#160; &#160;当体系的一部分组件失效，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
</li>
<li><p>送达保证</p>
<p>&#160; &#160; &#160; &#160;消息队列提供的冗余机制保证了消息能被实际的处理，只要一个进程读取了该队列即可。在此基础上，IronMQ提供了一个“只送达一次”保证。无论有多少进程在从队列中领取数据，每一个消息只能被处理一次。这之所以成为可能，是因为获取一个消息只是“预定”了这个消息，暂时把它移出了队列。除非客户端明确表示已经处理完了这个消息，否则这个消息会被放回队列中去，在一段可配置的时间之后再次被处理。</p>
</li>
<li><p>顺序保证</p>
<p>&#160; &#160; &#160; &#160;在大多使用场景下，数据处理的顺序都很重要。消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。IronMQ保证消息通过FIFO（先进先出）的顺序来处理，因为消息在队列中的位置就是从队列中检索出来他们的位置。</p>
</li>
<li><p>缓冲</p>
<p>&#160; &#160; &#160; &#160;在任何重要的系统中，都会有需要不同的处理时间的元素。例如：加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行，写入队列的处理会尽可能的快速，而不受从队列读的预备处理的约束。该缓冲有助于控制和优化数据流经过系统的速度。</p>
</li>
<li><p>理解数据流</p>
<p>&#160; &#160; &#160; &#160;在一个分布式系统里，要得到一个关于用户操作会用多长时间及其原因的总体印象，是一个巨大的挑战。消息队列通过消息被处理的频率，来方便的辅助确定那些表现不佳的处理过程或领域。</p>
</li>
<li><p>异步通信</p>
<p>&#160; &#160; &#160; &#160;很多时候，你不想也不需要立即处理消息。消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它。你想向队列放入多少消息就放多少，然后在你乐意的时候再去处理它们。</p>
</li>
</ul>
<h1 id="常用Message-Queue对比"><a href="#常用Message-Queue对比" class="headerlink" title="常用Message Queue对比"></a>常用Message Queue对比</h1><ul>
<li><p>RabbitMQ<br>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多协议：AMQP、XMPP、SMTP、STOMP,也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker架构，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</p>
</li>
<li><p>Redis<br>Redis是一个基于Key-Value对NoSql数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全当做一个轻量级的队列服务来使用，对于RabbitMQ和Redis的入队和出对操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes<br>521Bytes、1k和10k四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小写超过了10k。Rdis则慢的无法忍受；出队时，无论数据大小，Redis都表现非常好的性能，而RabbitMQ的出队性能则低于Redis.</p>
</li>
<li><p>ZeroMQ<br>ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上复杂度是对这个MQ能够应用成功的一个挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务角色。你只需要简单的引用ZeroMQ程序库，可以使NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模板）</p>
</li>
<li><p>ActiveMQ<br>ActiveMQ是Apache下的一个子项目。类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</p>
</li>
<li><p>Kafka/Jafka<br>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制来统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>
</li>
</ul>
<h1 id="Kafka解析"><a href="#Kafka解析" class="headerlink" title="Kafka解析"></a>Kafka解析</h1><h2 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h2><ul>
<li><p>Broker<br>Kafka集群包含一个或多个服务器，这种服务器被称为broker</p>
</li>
<li><p>Topic<br>每条发布到Kafka集群的消息都有一个类别，这个类别被称为topic。（物理上不同topic的消息分开存储，逻辑上一个topic的消息虽然保存于一个或多个broker上但用户只需指定消息的topic即可生产或消费数据而不必关心数据存于何处）</p>
</li>
<li><p>Partition<br>parition是物理上的概念，每个topic包含一个或多个partition，创建topic时可指定parition数量。每个partition对应于一个文件夹，该文件夹下存储该partition的数据和索引文件</p>
</li>
<li><p>Producer<br>负责发布消息到Kafka broker</p>
</li>
<li><p>Consumer<br>消费消息。每个consumer属于一个特定的consumer group（可为每个consumer指定group name，若不指定group name则属于默认的group）。使用consumer high level API时，同一topic的一条消息只能被同一个consumer group内的一个consumer消费，但多个consumer group可同时消费这一消息。</p>
</li>
</ul>
<h1 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h1><p><img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/kafka_1.png" class="lozad"></p>
<p>  &#160; &#160; &#160; &#160;如上图所示，一个典型的kafka集群中包含若干producer(可以是web前段产生的page view,或者是服务 器日志，系统CPU、存储memory)，若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干consumer group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader,以及在consumer group 发生变化时重新平衡(rebalance). producer使用push模式将消息发布到broker，consumer使用pull模式从broker订阅并消费消息.</p>
<h2 id="Push-vs-Pull"><a href="#Push-vs-Pull" class="headerlink" title="Push vs Pull"></a>Push vs Pull</h2><p>  &#160; &#160; &#160; &#160;作为一个message system ，Kafka遵循了传统的方式，选择由producer向broker push 消息并由consumer从broker pull消息数据。一些logging-system(日志系统)，比如Facebook的Scrilbe和Cloudera的Flume，采用非常不同的push模式。事实上，push模式和pull模式各有优劣。<br>  &#160; &#160; &#160; &#160;push模式很难适应消费速率不同的消费者，因为消息发送速率是有broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及出来消息，典型的表现就是拒绝服务以及网络阻塞。而pull模式可以根据consumer的消费能力以适当的速率消费消息。</p>
<h2 id="Topic-amp-Partition"><a href="#Topic-amp-Partition" class="headerlink" title="Topic &amp; Partition"></a>Topic &amp; Partition</h2><p>  &#160; &#160; &#160; &#160;Topic的逻辑上可以被认为是一个queue。每条消费都必须指定它的topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以水平扩展，物理上把topic分为一个或过个Partition,每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/topic-partition.png" class="lozad"></p>
<p>  `&#160; &#160; &#160; &#160;每个日子文件都是“log entries”序列，每一个log entry 包含一个4字节整型数(值为N)，其后跟N个字节的消息体。每条消息都有一个当前Partition下唯一的64字节的offset，它指明了这条消息的起始位置。磁盘上存储的消息格式如下：</p>
<pre><code>message length : 4bytes(values:1+4+n)
&quot;magic&quot; value :1 byte
crc : 4bytes
payload : n bytes
</code></pre><p>  &#160; &#160; &#160; &#160;这个“log entries” 并非由一个文件构成，而是分成多个(段)segment,每个segment名为该segment第一条消息的offset和”.kafka”组成。另外会有一个索引文件，它标明了每个segment下包含的log entry的offset范围，如下图示。</p>
<pre><code>//图片
</code></pre><p>  &#160; &#160; &#160; &#160;因为每条消息都被append到改partition中，是是顺序写磁盘，因此效率非常高(经验证明，顺序写磁盘效率比随机写内存还要高，这是kafka高吞吐率的一个很重要的保证)。</p>
<pre><code>//图片
</code></pre><p>  &#160; &#160; &#160; &#160;每一条消息被发送到broker时，会根据partition规则选择被存储到哪一个partition。如果partition规则设置的合理，所有消息可以均匀分布到不同的partition里，这样就实现了水平扩展。(如果一个topic对应一个文件，那这个文件所在的机器I/O将会成为这个topic的性能瓶颈，而partition解决了这个问题)。在创建topic时可以在$KAFKA_HOME/config/server.properties中指定这个partition的数量(如下所示)，当然也可以在topic创建之后去修改partition数量。</p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># The default number of log partitions per topic. More partitions allow greater</span><br><span class="line"># parallelism for consumption, but this will also result in more files across</span><br><span class="line"># the brokers.</span><br><span class="line">num.partitions=3</span><br></pre></td></tr></table></figure>
<p>  &#160; &#160; &#160; &#160;在发送一条消息时，可以指定这条消息的key，producer根据这个key和partition机制来判断将这条消息发送到哪个parition。paritition机制可以通过指定producer的paritition. class这一参数来指定，该class必须实现kafka.producer.Partitioner接口。本例中如果key可以被解析为整数则将对应的整数与partition总数取余，该消息会被发送到该数对应的partition。（每个parition都会有个序号）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kafka.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> kafka.utils.VerifiableProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JasonPartitioner</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JasonPartitioner</span><span class="params">(VerifiableProperties verifiableProperties)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Object key, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> partitionNum = Integer.parseInt((String) key);</span><br><span class="line">            <span class="keyword">return</span> Math.abs(Integer.parseInt((String) key) % numPartitions);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(key.hashCode() % numPartitions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  &#160; &#160; &#160; &#160;如果将上例中的class作为partitioner.class，并通过如下代码发送20条消息（key分别为0，1，2，3）至topic2（包含4个partition）。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void sendMessage() throws InterruptedException&#123;</span><br><span class="line">  　　      for(int i = 1; i &lt;= 5; i++)&#123;</span><br><span class="line">　　      List messageList = new ArrayList&lt;KeyedMessage&lt;String, String&gt;&gt;();</span><br><span class="line">　　      for(int j = 0; j &lt; 4; j++）&#123;</span><br><span class="line">          　　     messageList.add(new KeyedMessage&lt;String, String&gt;(&quot;topic2&quot;, j+&quot;&quot;, &quot;The &quot; + i + &quot; message for key &quot; + j));</span><br><span class="line">　　      &#125;</span><br><span class="line">　　      producer.send(messageList);</span><br><span class="line">      &#125;</span><br><span class="line">  　　producer.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  &#160; &#160; &#160; &#160;则key相同的消息会被发送并存储到同一个partition里，而且key的序号正好和partition序号相同。（partition序号从0开始，本例中的key也正好从0开始）。如下图所示。<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/partition_key.png" class="lozad"></p>
<p>  &#160; &#160; &#160; &#160;对于传统的message queue而言，一般会删除已经被消费的消息，而Kafka集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此Kafka提供两种策略去删除旧数据。一是基于时间，二是基于partition文件大小。例如可以通过配置$KAFKA_HOME/config/server.properties，让Kafka删除一周前的数据，也可通过配置让Kafka在partition文件超过1GB时删除旧数据，如下所示。<br>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>############################ Log Retention Policy #############################</span><br><span class="line"><span class="meta">#</span> The following configurations control the disposal of log segments. The policy can</span><br><span class="line"><span class="meta">#</span> be set to delete segments after a period of time, or after a given size has accumulated.</span><br><span class="line"><span class="meta">#</span> A segment will be deleted whenever *either* of these criteria are met. Deletion always happens</span><br><span class="line"><span class="meta">#</span> from the end of the log.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The minimum age of a log file to be eligible for deletion</span><br><span class="line">log.retention.hours=168</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> A size-based retention policy for logs. Segments are pruned from the log as long as the remaining</span><br><span class="line"><span class="meta">#</span> segments don't drop below log.retention.bytes.</span><br><span class="line"><span class="meta">#</span>log.retention.bytes=1073741824</span><br><span class="line"><span class="meta">#</span> The maximum size of a log segment file. When this size is reached a new log segment will be created.</span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The interval at which log segments are checked to see if they can be deleted according</span><br><span class="line"><span class="meta">#</span> to the retention policies</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> By default the log cleaner is disabled and the log retention policy will default to</span><br><span class="line"><span class="meta">#</span>just delete segments after their retention expires.</span><br><span class="line"><span class="meta">#</span> If log.cleaner.enable=true is set the cleaner will be enabled and individual logs</span><br><span class="line"><span class="meta">#</span>can then be marked for log compaction.</span><br><span class="line">log.cleaner.enable=false</span><br></pre></td></tr></table></figure></p>
<p>  &#160; &#160; &#160; &#160;这里要注意，因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除文件与Kafka性能无关，选择怎样的删除策略只与磁盘以及具体的需求有关。另外，Kafka会为每一个consumer group保留一些metadata信息–当前消费的消息的position，也即offset。这个offset由consumer控制。正常情况下consumer会在消费完一条消息后线性增加这个offset。当然，consumer也可将offset设成一个较小的值，重新消费一些消息。因为offet由consumer控制，所以Kafka broker是无状态的，它不需要标记哪些消息被哪些consumer过，不需要通过broker去保证同一个consumer group只有一个consumer能消费某一条消息，因此也就不需要锁机制，这也为Kafka的高吞吐率提供了有力保障。</p>
<h2 id="Replication-amp-Leader-election"><a href="#Replication-amp-Leader-election" class="headerlink" title="Replication &amp; Leader election"></a>Replication &amp; Leader election</h2><p>  &#160; &#160; &#160; &#160;Kafka从0.8开始提供partition级别的replication，replication的数量可在$KAFKA_HOME/config/server.properties中配置。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default.replication.factor = 1</span><br></pre></td></tr></table></figure></p>
<p>  &#160; &#160; &#160; &#160;该 Replication与leader election配合提供了自动的failover机制。replication对Kafka的吞吐率是有一定影响的，但极大的增强了可用性。默认情况下，Kafka的replication数量为1。　　每个partition都有一个唯一的leader，所有的读写操作都在leader上完成，leader批量从leader上pull数据。一般情况下partition的数量大于等于broker的数量，并且所有partition的leader均匀分布在broker上。follower上的日志和其leader上的完全一样。<br>  &#160; &#160; &#160; &#160;和大部分分布式系统一样，Kakfa处理失败需要明确定义一个broker是否alive。对于Kafka而言，Kafka存活包含两个条件，一是它必须维护与Zookeeper的session(这个通过Zookeeper的heartbeat机制来实现)。二是follower必须能够及时将leader的writing复制过来，不能“落后太多”。<br>  &#160; &#160; &#160; &#160;leader会track“in sync”的node list。如果一个follower宕机，或者落后太多，leader将把它从”in sync” list中移除。这里所描述的“落后太多”指follower复制的消息落后于leader后的条数超过预定值，该值可在$KAFKA_HOME/config/server.properties中配置<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#If a replica falls more than this many messages behind the leader, the leader will remove the follower from ISR and treat it as dead</span><br><span class="line">replica.lag.max.messages=4000</span><br><span class="line"></span><br><span class="line">#If a follower hasn&apos;t sent any fetch requests for this window of time, the leader will remove the follower from ISR (in-sync replicas) and treat it as dead</span><br><span class="line">replica.lag.time.max.ms=10000</span><br></pre></td></tr></table></figure></p>
<p>  &#160; &#160; &#160; &#160;需要说明的是，Kafka只解决”fail/recover”，不处理“Byzantine”（“拜占庭”）问题。<a href="http://www.cnblogs.com/meihao1989/archive/2013/05/11/3073446.html" target="_blank" rel="noopener">[拜占庭详解]</a><br>  &#160; &#160; &#160; &#160;一条消息只有被“in sync” list里的所有follower都从leader复制过去才会被认为已提交。这样就避免了部分数据被写进了leader，还没来得及被任何follower复制就宕机了，而造成数据丢失（consumer无法消费这些数据）。而对于producer而言，它可以选择是否等待消息commit，这可以通过request.required.acks来设置。这种机制确保了只要“in sync” list有一个或以上的flollower，一条被commit的消息就不会丢失。<br>  &#160; &#160; &#160; &#160;这里的复制机制即不是同步复制，也不是单纯的异步复制。事实上，同步复制要求“活着的”follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率（高吞吐率是Kafka非常重要的一个特性）。而异步复制方式下，follower异步的从leader复制数据，数据只要被leader写入log就被认为已经commit，这种情况下如果follwer都落后于leader，而leader突然宕机，则会丢失数据。而Kafka的这种使用“in sync” list的方式则很好的均衡了确保数据不丢失以及吞吐率。follower可以批量的从leader复制数据，这样极大的提高复制性能（批量写磁盘），极大减少了follower与leader的差距（前文有说到，只要follower落后leader不太远，则被认为在“in sync” list里）。</p>
<p>  &#160; &#160; &#160; &#160;上文说明了Kafka是如何做replication的，另外一个很重要的问题是当leader宕机了，怎样在follower中选举出新的leader。因为follower可能落后许多或者crash了，所以必须确保选择“最新”的follower作为新的leader。一个基本的原则就是，如果leader不在了，新的leader必须拥有原来的leader commit的所有消息。这就需要作一个折衷，如果leader在标明一条消息被commit前等待更多的follower确认，那在它die之后就有更多的follower可以作为新的leader，但这也会造成吞吐率的下降。<br>  &#160; &#160; &#160; &#160;一种非常常用的选举leader的方式是“majority vote”（“少数服从多数”），但Kafka并未采用这种方式。这种模式下，如果我们有2f+1个replica（包含leader和follower），那在commit之前必须保证有f+1个replica复制完消息，为了保证正确选出新的leader，fail的replica不能超过f个。因为在剩下的任意f+1个replica里，至少有一个replica包含有最新的所有消息。这种方式有个很大的优势，系统的latency只取决于最快的几台server，也就是说，如果replication factor是3，那latency就取决于最快的那个follower而非最慢那个。majority vote也有一些劣势，为了保证leader election的正常进行，它所能容忍的fail的follower个数比较少。如果要容忍1个follower挂掉，必须要有3个以上的replica，如果要容忍2个follower挂掉，必须要有5个以上的replica。也就是说，在生产环境下为了保证较高的容错程度，必须要有大量的replica，而大量的replica又会在大数据量下导致性能的急剧下降。这就是这种算法更多用在Zookeeper这种共享集群配置的系统中而很少在需要存储大量数据的系统中使用的原因。例如HDFS的HA feature是基于majority-vote-based journal，但是它的数据存储并没有使用这种expensive的方式。<br>  &#160; &#160; &#160; &#160;实际上，leader election算法非常多，比如Zookeper的Zab, Raft和Viewstamped Replication。而Kafka所使用的leader election算法更像微软的PacificA算法。<br>  &#160; &#160; &#160; &#160;Kafka在Zookeeper中动态维护了一个ISR（in-sync replicas） set，这个set里的所有replica都跟上了leader，只有ISR里的成员才有被选为leader的可能。在这种模式下，对于f+1个replica，一个Kafka topic能在保证不丢失已经ommit的消息的前提下容忍f个replica的失败。在大多数使用场景中，这种模式是非常有利的。事实上，为了容忍f个replica的失败，majority vote和ISR在commit前需要等待的replica数量是一样的，但是ISR需要的总的replica的个数几乎是majority vote的一半。<br>  &#160; &#160; &#160; &#160;虽然majority vote与ISR相比有不需等待最慢的server这一优势，但是Kafka作者认为Kafka可以通过producer选择是否被commit阻塞来改善这一问题，并且节省下来的replica和磁盘使得ISR模式仍然值得。</p>
<p>  &#160; &#160; &#160; &#160;上文提到，在ISR中至少有一个follower时，Kafka可以确保已经commit的数据不丢失，但如果某一个partition的所有replica都挂了，就无法保证数据不丢失了。这种情况下有两种可行的方案：</p>
<ul>
<li>等待ISR中的任一个replica“活”过来，并且选它作为leader</li>
<li>选择第一个“活”过来的replica（不一定是ISR中的）作为leader</li>
</ul>
<p>&#160; &#160; &#160; &#160;这就需要在可用性和一致性当中作出一个简单的平衡。如果一定要等待ISR中的replica“活”过来，那不可用的时间就可能会相对较长。而且如果ISR中的所有replica都无法“活”过来了，或者数据都丢失了，这个partition将永远不可用。选择第一个“活”过来的replica作为leader，而这个replica不是ISR中的replica，那即使它并不保证已经包含了所有已commit的消息，它也会成为leader而作为consumer的数据源（前文有说明，所有读写都由leader完成）。Kafka0.8.*使用了第二种方式。根据Kafka的文档，在以后的版本中，Kafka支持用户通过配置选择这两种方式中的一种，从而根据不同的使用场景选择高可用性还是强一致性。</p>
<p>&#160; &#160; &#160; &#160;上文说明了一个parition的replication过程，然尔Kafka集群需要管理成百上千个partition，Kafka通过round-robin的方式来平衡partition从而避免大量partition集中在了少数几个节点上。同时Kafka也需要平衡leader的分布，尽可能的让所有partition的leader均匀分布在不同broker上。另一方面，优化leadership election的过程也是很重要的，毕竟这段时间相应的partition处于不可用状态。一种简单的实现是暂停宕机的broker上的所有partition，并为之选举leader。实际上，Kafka选举一个broker作为controller，这个controller通过watch Zookeeper检测所有的broker failure，并负责为所有受影响的parition选举leader，再将相应的leader调整命令发送至受影响的broker，过程如下图所示。<br>  //图片<br>&#160; &#160; &#160; &#160;这样做的好处是，可以批量的通知leadership的变化，从而使得选举过程成本更低，尤其对大量的partition而言。如果controller失败了，幸存的所有broker都会尝试在Zookeeper中创建/controller-&gt;{this broker id}，如果创建成功（只可能有一个创建成功），则该broker会成为controller，若创建不成功，则该broker会等待新controller的命令。<br>  //图片</p>
<h2 id="Consumer-group"><a href="#Consumer-group" class="headerlink" title="Consumer group"></a>Consumer group</h2><p>  &#160; &#160; &#160; &#160;（本节所有描述都是基于consumer hight level API而非low level API）。<br>  &#160; &#160; &#160; &#160;每一个consumer实例都属于一个consumer group，每一条消息只会被同一个consumer group里的一个consumer实例消费。（不同consumer group可以同时消费同一条消息）<br>  //图片</p>
<p>  &#160; &#160; &#160; &#160;很多传统的message queue都会在消息被消费完后将消息删除，一方面避免重复消费，另一方面可以保证queue的长度比较少，提高效率。而如上文所将，Kafka并不删除已消费的消息，为了实现传统message queue消息只被消费一次的语义，Kafka保证保证同一个consumer group里只有一个consumer会消费一条消息。与传统message queue不同的是，Kafka还允许不同consumer group同时消费同一条消息，这一特性可以为消息的多元化处理提供了支持。实际上，Kafka的设计理念之一就是同时提供离线处理和实时处理。根据这一特性，可以使用Storm这种实时流处理系统对消息进行实时在线处理，同时使用Hadoop这种批处理系统进行离线处理，还可以同时将数据实时备份到另一个数据中心，只需要保证这三个操作所使用的consumer在不同的consumer group即可。下图展示了Kafka在Linkedin的一种简化部署。<br>  //图片<br>  &#160; &#160; &#160; &#160;为了更清晰展示Kafka consumer group的特性，笔者作了一项测试。创建一个topic (名为topic1)，创建一个属于group1的consumer实例，并创建三个属于group2的consumer实例，然后通过producer向topic1发送key分别为1，2，3r的消息。结果发现属于group1的consumer收到了所有的这三条消息，同时group2中的3个consumer分别收到了key为1，2，3的消息。如下图所示。<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/consumer_group_test.png" class="lozad"></p>
<h2 id="Consumer-Rebalance"><a href="#Consumer-Rebalance" class="headerlink" title="Consumer Rebalance"></a>Consumer Rebalance</h2><p>  &#160; &#160; &#160; &#160;Kafka保证同一consumer group中只有一个consumer会消费某条消息，实际上，Kafka保证的是稳定状态下每一个consumer实例只会消费某一个或多个特定partition的数据，而某个partition的数据只会被某一个特定的consumer实例所消费。这样设计的劣势是无法让同一个consumer group里的consumer均匀消费数据，优势是每个consumer不用都跟大量的broker通信，减少通信开销，同时也降低了分配难度，实现也更简单。另外，因为同一个partition里的数据是有序的，这种设计可以保证每个partition里的数据也是有序被消费。<br>  &#160; &#160; &#160; &#160;如果某consumer group中consumer数量少于partition数量，则至少有一个consumer会消费多个partition的数据，如果consumer的数量与partition数量相同，则正好一个consumer消费一个partition的数据，而如果consumer的数量多于partition的数量时，会有部分consumer无法消费该topic下任何一条消息。<br>  &#160; &#160; &#160; &#160;如下例所示，如果topic1有0，1，2共三个partition，当group1只有一个consumer(名为consumer1)时，该 consumer可消费这3个partition的所有数据。<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/group1_consumer1.png" class="lozad"><br>  &#160; &#160; &#160; &#160;增加一个consumer(consumer2)后，其中一个consumer（consumer1）可消费2个partition的数据，另外一个consumer(consumer2)可消费另外一个partition的数据。<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/group1_consumer_1_2.png" class="lozad"><br>  &#160; &#160; &#160; &#160;再增加一个consumer(consumer3)后，每个consumer可消费一个partition的数据。consumer1消费partition0，consumer2消费partition1，consumer3消费partition2<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/group1_consumer_1_2_3.png" class="lozad"></p>
<p>  #160; &#160; &#160; &#160;再增加一个consumer（consumer4）后，其中3个consumer可分别消费一个partition的数据，另外一个consumer（consumer4）不能消费topic1任何数据。<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/group1_consumer_1_2_3_4.png" class="lozad"></p>
<p>  #160; &#160; &#160; &#160;此时关闭consumer1，剩下的consumer可分别消费一个partition的数据。<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/group1_consumer_2_3_4.png" class="lozad"></p>
<p>  #160; &#160; &#160; &#160;接着关闭consumer2，剩下的consumer3可消费2个partition，consumer4可消费1个partition。<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/group1_consumer_3_4.png" class="lozad"></p>
<p>  #160; &#160; &#160; &#160;再关闭consumer3，剩下的consumer4可同时消费topic1的3个partition。<br>  <img alt="jdk" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/group1_consumer_4.png" class="lozad"></p>
<h2 id="消息Deliver-guarantee"><a href="#消息Deliver-guarantee" class="headerlink" title="消息Deliver guarantee"></a>消息Deliver guarantee</h2><p>  &#160; &#160; &#160; &#160;通过上文介绍，想必读者已经明白了producer和consumer是如何工作的，以及Kafka是如何做replication的，接下来要讨论的是Kafka如何确保消息在producer和consumer之间传输。有这么几种可能的delivery guarantee：</p>
<ul>
<li>At most once 消息可能会丢，但绝不会重复传输</li>
<li>At least one 消息绝不会丢，但可能会重复传输</li>
<li>Exactly once 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。</li>
</ul>
<p>&#160; &#160; &#160; &#160;Kafka的delivery guarantee semantic非常直接。当producer向broker发送消息时，一旦这条消息被commit，因数replication的存在，它就不会丢。但是如果producer发送数据给broker后，遇到的网络问题而造成通信中断，那producer就无法判断该条消息是否已经commit。这一点有点像向一个自动生成primary key的数据库表中插入数据。虽然Kafka无法确定网络故障期间发生了什么，但是producer可以生成一种类似于primary key的东西，发生故障时幂等性的retry多次，这样就做到了Exactly one。截止到目前(Kafka 0.8.2版本，2015-01-25)，这一feature还并未实现，有希望在Kafka未来的版本中实现。（所以目前默认情况下一条消息从producer和broker是确保了At least once，但可通过设置producer异步发送实现At most once）。</p>
<ul>
<li>读完消息先commit再处理消息。这种模式下，如果consumer在commit后还没来得及处理消息就crash了，下次重新开始工作后就无法读到刚刚已提交而未处理的消息，这就对应于At most once</li>
<li>读完消息先处理再commit。这种模式下，如果处理完了消息在commit之前consumer crash了，下次重新开始工作时还会处理刚刚未commit的消息，实际上该消息已经被处理过了。这就对应于At least once。在很多情况使用场景下，消息都有一个primary key，所以消息的处理往往具有幂等性，即多次处理这一条消息跟只处理一次是等效的，那就可以认为是Exactly once。（人个感觉这种说法有些牵强，毕竟它不是Kafka本身提供的机制，而且primary key本身不保证操作的幂等性。而且实际上我们说delivery guarantee semantic是讨论被处理多少次，而非处理结果怎样，因为处理方式多种多样，我们的系统不应该把处理过程的特性–如是否幂等性，当成Kafka本身的feature）</li>
<li>如果一定要做到Exactly once，就需要协调offset和实际操作的输出。精典的做法是引入两阶段提交。如果能让offset和操作输入存在同一个地方，会更简洁和通用。这种方式可能更好，因为许多输出系统可能不支持两阶段提交。比如，consumer拿到数据后可能把数据放到HDFS，如果把最新的offset和数据本身一起写到HDFS，那就可以保证数据的输出和offset的更新要么都完成，要么都不完成，间接实现Exactly once。（目前就high level API而言，offset是存于Zookeeper中的，无法存于HDFS，而low level API的offset是由自己去维护的，可以将之存于HDFS中）</li>
</ul>
<p>&#160; &#160; &#160; &#160;总之，Kafka默认保证At least once，并且允许通过设置producer异步提交来实现At most once。而Exactly once要求与目标存储系统协作，幸运的是Kafka提供的offset可以使用这种方式非常直接非常容易。</p>
<p>  原文链接　<a href="https://www.jasongj.com/2015/01/02/Kafka深度解析" target="_blank" rel="noopener">[https://www.jasongj.com/2015/01/02/Kafka深度解析]</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陈 武</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.updatecg.xin/2017/09/03/【Apache Kafka 细节二】Kafka背景及架构介绍/">http://www.updatecg.xin/2017/09/03/【Apache Kafka 细节二】Kafka背景及架构介绍/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.updatecg.xin">我的学习记录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kafka/">Kafka    </a></div><div class="post_share"><div class="social-share" data-image="https://updatecg.oss-cn-beijing.aliyuncs.com/timg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="img/cgs.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="img/zhifubao.png"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2017/09/09/JavaSE8/"><img class="prev_cover lozad" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/wallhaven-gj2j2l.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>JavaSE 8</span></div></a></div><div class="next-post pull-right"><a href="/2017/08/25/路上/"><img class="next_cover lozad" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/wallhaven-gj2j2l.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>路上</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2017/09/25/SpringBoot下ELK+KAFKA+SpringAop日志分析/" title="SpringBoot下ELK+KAFKA+SpringAop日志分析"><img class="relatedPosts_cover lozad" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/wallhaven-gj2j2l.jpg"><div class="relatedPosts_title">SpringBoot下ELK+KAFKA+SpringAop日志分析</div></a></div><div class="relatedPosts_item"><a href="/2017/08/25/【Apache Kafka 细节一】Kafka安装/" title="【Apache Kafka 细节一】Kafka安装"><img class="relatedPosts_cover lozad" data-src="https://updatecg.oss-cn-beijing.aliyuncs.com/wallhaven-gj2j2l.jpg"><div class="relatedPosts_title">【Apache Kafka 细节一】Kafka安装</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'QWEsCLTRaW2S9rUPn8Mq28CU-gzGzoHsz',
  appKey:'0b5xzRKTdodumxJJ1wYXcLWe',
  placeholder:'欢迎建议留言...',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2021 By 陈 武</div><div class="icp"><a href="https://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank"><img class="lozad" data-src="https://www.larscheng.com/img/beian.png" onerror="onerror=null;src='https://www.larscheng.com/img/beian.png'" style="padding:0px;vertical-align: text-bottom;"><span>蜀ICP备19024604号</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#摘要"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">摘要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#背景介绍"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">背景介绍</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Kafka创建背景"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">Kafka创建背景</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Kafka简介"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">Kafka简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为何使用消息系统"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">为何使用消息系统</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#常用Message-Queue对比"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">常用Message Queue对比</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Kafka解析"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Kafka解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Terminology"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">Terminology</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Kafka架构"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Kafka架构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Push-vs-Pull"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">Push vs Pull</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Topic-amp-Partition"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">Topic &amp; Partition</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Replication-amp-Leader-election"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">Replication &amp; Leader election</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Consumer-group"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">Consumer group</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Consumer-Rebalance"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text">Consumer Rebalance</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#消息Deliver-guarantee"><span class="toc_mobile_items-number">5.6.</span> <span class="toc_mobile_items-text">消息Deliver guarantee</span></a></li></ol></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script></body></html>